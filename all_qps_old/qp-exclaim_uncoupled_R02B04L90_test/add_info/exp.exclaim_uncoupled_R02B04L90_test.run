#! /bin/ksh
#=============================================================================

# daint gpu batch job parameters
# ------------------------------
#SBATCH --constraint=gpu
#SBATCH --account=d121
#SBATCH --job-name=exp.exclaim_uncoupled_R02B04L90_test.run
#SBATCH --output=/scratch/snx3000/ppothapa/dsl_0.3_bugfix_gmean/v0.3.0-rc/run/LOG.exp.exclaim_uncoupled_R02B04L90_test.run.%j.o
#SBATCH --error=/scratch/snx3000/ppothapa/dsl_0.3_bugfix_gmean/v0.3.0-rc/run/LOG.exp.exclaim_uncoupled_R02B04L90_test.run.%j.o
#SBATCH --nodes=10
#SBATCH --ntasks-per-node=1
#SBATCH --time=20:20:00
#
#=============================================================================
set +x
ulimit -s unlimited
#=============================================================================
#
# ICON run script:
# !ATTENTION! Do not change the format of the following lines.
#             They are evaluated by checksuite scripts.
# created by /project/sm83/ckroll/ICONc2sm/icon/run/make_target_runscript    (Adapted to the v3.0 for Pothapakula)
# target machine is daint_gpu
# target use_compiler is pgi
# with_mpi=yes
# with_openmp=no
# memory_model=large
# submit with sbatch
#
builder=daint_gpu_pgi
#=============================================================================
#
# OpenMP environment variables
# ----------------------------
export OMP_NUM_THREADS=1
export ICON_THREADS=1
export OMP_SCHEDULE=static,1
export OMP_DYNAMIC="false"
export OMP_STACKSIZE=200M
export CRAY_CUDA_MPS=1
export MPICH_RDMA_ENABLED_CUDA=1

#
# MPI variables
# -------------
ionodes=1 #26    # 30 files 23 3D, 6 2D, 1 1D
no_of_nodes=${SLURM_JOB_NUM_NODES:-1}
mpi_procs_pernode=1
((mpi_total_procs=no_of_nodes * mpi_procs_pernode))
#
# blocking length
# ---------------
nproma=5000   # 491520 / n_compute nodes = 12288., was 13500 before
#R2B4 edges 30720, 
#n1 =30700,  nproma_sub=800 probably
#n2 = 15400, nproma_sub = 1500
#n3 =10500, nproma_sub = 1500
nproma_sub=1500
nblocks_c=0
# start with nproma_sub =800
# start with nproma_sub =800
#=============================================================================

# load local setting, if existing
# -------------------------------
if [ -a ../setting ]
then
  echo "Load Setting"
  . ../setting
fi

# environment variables for the experiment and the target system
# --------------------------------------------------------------
export EXPNAME="exclaim_uncoupled_R02B04L90_test"
# load profile
# ------------
if [[ -a  /opt/modules/default/etc/modules.sh ]]
then
	. /opt/modules/default/etc/modules.sh
fi

#=============================================================================
# directories with absolute paths
# -------------------------------
thisdir=$(pwd)
basedir="/scratch/snx3000/ppothapa/dsl_0.3_bugfix_gmean/v0.3.0-rc"
bindir="/scratch/snx3000/ppothapa/dsl_0.3_bugfix_gmean/v0.3.0-rc/bin"

# experiments_dir can be predefined in a machine specific run_target_* header
experiments_dir="${experiments_dir:=${basedir}/experiments}"
export basedir
icon_data_rootFolder="/users/icontest/pool/data/ICON"

# how to start the icon model
# ---------------------------
export START="srun -n $mpi_total_procs --ntasks-per-node $mpi_procs_pernode --threads-per-core=1 --gpus-per-task $OMP_NUM_THREADS"
export MODEL="${bindir}/icon"


set | grep SLURM

# how to submit the next job
# --------------------------
submit="sbatch"
job_name="exp.exclaim_uncoupled_R02B04L90_test.run"

# cdo for post-processing
# -----------------------
cdo="cdo"
cdo_diff="cdo diffn"

# define script functions used in the experiment run script
# ---------------------------------------------------------
. /scratch/snx3000/ppothapa/dsl_0.3_bugfix_gmean/v0.3.0-rc/run/add_run_routines
#=============================================================================

#export PGI_ACC_SYNCHRONOUS=1
export ECCODES_DEFINITION_PATH=/users/icontest/pool/data/ICON/mch/eccodes_definitions
#_____________________________________________________________________________
#
author_list="Pothapakula, Clarissa Kroll, ETH, Luis Kornblueh, MPIM, Andrea Schneidereit, DWD, Ulrike Niemeier, MPIM and ICON-CLM community"
#_____________________________________________________________________________

RES=R02B04
gridID=0013
   
input_folder=/scratch/snx3000/ppothapa/for_praveen/${gridID}  

start_date="1979-01-01T00:00:00"
end_date="1982-01-01T00:00:00"


# date related vars "Adapted from DWD test suite experiments"
YYYY=`echo ${start_date} |cut -c 1-4`
PREV_YYYY=`expr ${YYYY} - 1`
NEXT_YYYY=`expr ${YYYY} + 1`
MM=`echo ${start_date} |cut -c 6-7`
if [[ ${MM} == "12" ]]
then
  NEXT_MM=1
else
  NEXT_MM=`expr ${MM} + 1`
fi
[[ ${NEXT_MM} -lt 10 ]] && NEXT_MM=`echo 0${NEXT_MM}`



timestep="PT360S" 
dtime=360
timestep_phy=360




outputdir=${basedir}/experiments/${EXPNAME}
atmo_dyn_grid_dir=${input_folder}
analysis_file=${input_folder}/initial_conditions/ifs2icon_1979010100_${gridID}_${RES}_G.nc 
extpar_file=${input_folder}/external_parameter_${gridID}_${RES}_G_tiles_ppk.nc 
sst_file_dir=${input_folder}/sst_and_seaice
ice_file_dir=${input_folder}/sst_and_seaice
#ice_file=${input_folder}/sst_and_seaice

ecrad_file=${basedir}/externals/ecrad/data

#Link SST files to the run directory. 

#ln -sf ${sst_file_dir}/SST_*_*_icon_grid_0013_R02B04_G.nc .
#ln -sf ${ice_file_dir}/CI_*_*_icon_grid_0013_R02B04_G.nc .



atmo_dyn_grid="icon_grid_0013_R02B04_G.nc"




checkpoint_interval="P6M" 
restart_interval="P6M"     


atm_output_interval="P1M"
atm_output_interval_1d="P1M" 
atm_output_interval_2d="P1M"
atm_output_interval_3d="P1M"

atm_file_interval="P1M"
atm_file_interval_1week="P1M"



### 2D and 3D  output switches.   

output_atm_2d=yes

output_atm_3d=yes


output_atm_2d_CLM=no

output_atm_3d_CLM=no

# monitoring output switches    (for pyICON)
output_atm_mon=yes



# From CLM namelist for accumulating few variables within time of Interest. Exclusively for Rain

PRECIP_INTERVAL=PT24H # interval for accumulating tot_prec in ISO8601 (needs to be consistent with HOUT_INC above)
RUNOFF_INTERVAL=PT24H # interval for accumulating runoff in ISO8601 (needs to be consistent with HOUT_INC above)
SUNSHINE_INTERVAL=PT24H # interval for accumulating sunshine duration in ISO8601 (needs to be consistent with HOUT_INC above)
MAXT_INTERVAL=PT24H # interval for min/max of 2m-temperature in ISO8601 (needs to be consistent with HOUT_INC above)
GUST_INTERVAL=PT24H # interval for maximum of gust in 10m in ISO8601 (needs to be consistent with HOUT_INC above)
MELT_INTERVAL=PT24H # interval for accumulating snow_melt in ISO8601 (needs to be consistent with HOUT_INC above)

# Soil Layers for TERRA
ZML_SOIL="0.005,0.02,0.06,0.18,0.54,1.62,4.86,14.58"

# Lists the loaded modules during the run time of the model-
module list

# Restart = TRUE

restart = .true.


#_____________________________________________________________________________
# namelist file
if [ ! -d "$outputdir" ]; then
  echo "Outputdir does not exist. Creating $outputdir..."
  mkdir -p "$outputdir"
else
  echo "outputdir already exists."
fi
atmo_namelist="${basedir}/experiments/${EXPNAME}/NAMELIST_${EXPNAME}"

cat > ${atmo_namelist} << EOF

&parallel_nml
 nproma                       = $nproma             ! CK nproma  after Abishek: edge/(compute nodes)+20
 nblocks_c                    = $nblocks_c       ! CK for GPU calculations according Abishek = 1 for icon dsl
 nproma_sub                   = $nproma_sub              ! CK adapted according to JJ for Daint, saves compute nodes
 p_test_run                   = .false.         ! From CLM namelist  (Used for MPI Verification)
 l_test_openmp                = .false.         ! From CLM namelist  (Used for OpenMP verification)
 l_log_checks                 = .true.          ! From CLM namelist  (True only for debugging)
 num_io_procs                 = ${ionodes}      ! Suggestion (One Node for one set of variables)
 num_restart_procs            = 0               ! For Large Restart chuck, use enough number of Processors
 io_proc_chunk_size           = 4               ! Used for Large Data writing requiring large memory (eg., 3D files)
 iorder_sendrecv              = 3               ! From CLM namelist  (isend/irec)
! itype_comm                   = 1           !NEW    ! From CLM namelist  (use local memory)
! proc0_shift                  = 0           !NEW    ! From CLM namelist  (Processors at begining of rank excluded from DC)
! use_omp_input                = .false.     !NEW    ! From CLM namelist  (Use OpenMP for initialisation)
/

&grid_nml
 dynamics_grid_filename       = "${atmo_dyn_grid}"
 lredgrid_phys                = .FALSE.                                          ! Incase Reduced grid is used for Radiation turn to TRUE
/

&initicon_nml
! initialization mode (2 for IFS ana, 1 for DWD ana, 4=cosmo, 2=ifs, 3=combined
 init_mode                    = 2
 ifs2icon_filename            = "${analysis_file}"
 zpbl1                        = 500.    !NEW Works  !(CLM) bottom height (AGL) of layer used for gradient computation
 zpbl2                        = 1000.   !NEW Works    !(CLM) top height (AGL) of layer used for gradient computation
 ltile_init                   =.true.   !NEW Works   !(CLM) True: initialize tiled surface fields from a first guess coming from a run without tiles.
 ltile_coldstart              =.true.   !NEW Works  ! (CLM) If true, tiled surface fields are initialized with tile-averaged fields from a previous run with tiles.
/

&run_nml
 modelTimeStep                = "${timestep}"    ! Consistent with Aquaplanet run we tried 80Sec
 num_lev                      =  90              ! AD suggested 90 levels, in line with Dyamond simulations.
 lvert_nest                   = .false.          ! No vertical nesting (but may be good option for high resolutio)
 ldynamics                    = .true.      ! dynamics
 ltransport                   = .true.      ! Tracer Transport is true
 ntracer                      = 5           ! AD suggestion
 iforcing                     = 3           ! NWP forcing
 lart                         = .false.     ! Aerosol and TraceGases ART package from KIT
 ltestcase                    = .false.     ! false: run with real data
 msg_level                    =  5           ! default: 5, much more: 20; CLM uses 13 for bebug and 0 for production run
 ltimer                       = .true.      ! Timer for monitoring runtime for specific routines
 activate_sync_timers         = .true.      !  Timer for monitoring runtime communication routines-
 timers_level                 = 10          ! Level of timer monitoring   (1 is default value)
 output                       = 'nml'       ! nml stands for new output mode
 check_uuid_gracefully        = .true.      ! Warnings for non-matching UUIDs
/

&io_nml
 itype_pres_msl               = 5       ! Method for comoputing mean sea level pressure (Mixture of IFS and GME model DWD)
 itype_rh                     = 1       ! RH w.r.t. water (WMO type Water only)
 restart_file_type            = 5       ! 4: netcdf2, 5: netcdf4  (Consistent across model output, netcdf4)
!restart_write_mode          = "joint procs multifile"    ! For Large Runs Joint procs is recomemded from our experience
 lflux_avg                    = .true.   ! "FALSE" output fluxes are accumulated from the beginning of the run, "TRUE" average values
 lnetcdf_flt64_output         = .false.  ! Default value is false (CK)
 precip_interval              = "${PRECIP_INTERVAL}" !NEW ! Works The precipitation value is accumulated in these interval otherwise accumulated fromm begining of the run
 runoff_interval              = "${RUNOFF_INTERVAL}" !NEW ! Works The runoff is accumalted in this inetrval else accumulated from bengining.
 maxt_interval                = "${MAXT_INTERVAL}"   !NEW ! Works Interval at which Max/Min 2m temperture are calculated
 melt_interval               = "${MELT_INTERVAL}"   !NEW  ! Works CLM community has this , Can not find discription
 lmask_boundary               = .true.             !NEW  ! Works if interpolation zone should be masked in triangular output.
/

&nwp_phy_nml
 inwp_gscp                    = 2,    ! COSMO-DE cloud microphysisi 3 catogories, cloud-ice, snow, groupel
 mu_rain                      = 0.5   !NEW  CLM community (shape parameter in gamma distribution for rain)
 rain_n0_factor               = 0.1   !NEW  CLM community (tuning factor for intercept parameter of raindrop size distribution)
 icalc_reff                   = 0     ! Parametrization diagnostic calculation of effective radius
 inwp_convection              = 1     ! Tiedtke/Bechtold convection scheme on for R02B08
 inwp_radiation               = 4     ! 4 for ecRad radiation scheme
 inwp_cldcover                = 1     ! 0: no cld, 1: new diagnostic (M Koehler), 3: COSMO, 5: grid scale (CLM uses 1)
 inwp_turb                    = 1     ! 1 (COSMO diffusion and transfer)
 inwp_satad                   = 1     ! Saturation adjustment at constant densit (CLM community)
 inwp_sso                     = 1     !  Sub-grid scale orographic drag   (Lott and Miller Scheme (COMSO))
 inwp_gwd                     = 1     !  Non Orographic gravity wave drag (Orr-Ern-Bechtold Scheme)
 inwp_surface                 = 1     !  1 is TERRA and 2 is JSBACH.
 icapdcycl                    = 3     !  Type of Cape Correction for improving diurnal cycle (correction over land restricted to land , no correction over ocean, appklication over tropic)
 itype_z0                     = 2       !  CLM community uses 2: (land-cover-related roughness based on tile-specific landuse class)
 dt_conv                      = $(( 6 * timestep_phy))     !AD specific  recomendation  (Convection call)
 dt_sso                       = $(( 6 * timestep_phy))   ! AD specific recomendation   (sub surface orography call)
 dt_gwd                       = $(( 6 * timestep_phy))   ! AD specific recomendation   (gravity wave drag call)
 dt_rad                       = $((12 * timestep_phy))    ! AD specific recomendation   (radiation call)
 dt_ccov                      = $(( 6 * timestep_phy))  ! AD specific recomendation   (cloud cover call)
 latm_above_top               = .false.           ! Take into atmo above model top for cloud cover calculation (TRUE for CLM community)
 efdt_min_raylfric            = 7200.0            ! Minimum e-folding time for Rayleigh friction ( for inwp_gwd > 0) (CLM community)
 icpl_aero_conv               = 1                 ! Coupling of Tegen aerosol climmatology ( for irad_aero = 6)
 icpl_aero_gscp               = 1                 ! Coupling of aerosol tto large scale preciptation
 ldetrain_conv_prec           = .true.            ! Detraintment of convective rain and snow. (for inwp_convection = 1)
 lrtm_filename                = "/scratch/snx3000/ckroll/pac3ts/common/rrtmg_lw.nc" ! (rrtm inactive)
 cldopt_filename              = "/scratch/snx3000/ckroll/pac3ts/common/ECHAM6_CldOptProps.nc" ! RRTM inactive
/

&radiation_nml
 ecrad_isolver                =   2   ! CK comment (for GPU =2 , CPU = 0)
 irad_o3                      =  79   ! CLM communitny recomendation   (ice from tracer variable)
 irad_o2                      = 2           ! Tracer variable (CLM commnity)
 irad_cfc11                   = 2           ! Tracer variableTracer variable (co2, ch4,n20,o2,cfc11,cfc12))
 irad_cfc12                   = 2           ! Tracer Variable (cfc12)
 irad_aero                    = 6           ! Aerosol data ( Tegen aerosol climatology)
 albedo_type                  = 2           !  2: Modis albedo
 direct_albedo                = 4           !NEW direct beam surface albedo (Briegleb & Ramanatha for snow-free land points, Ritter-Geleyn for ice and Zängl for snow)
 albedo_whitecap              = 1           ! NEW CLM community (whitecap describtion by Seferian et al 2018)
 vmr_co2                      = 390.e-06    ! Volume mixing ratio if radiative agents
 vmr_ch4                      = 1800.e-09   ! CK namelist (not default value in ICON)
 vmr_n2o                      = 322.0e-09   ! CK namelist (not default value in ICON)
 vmr_o2                       = 0.20946     ! CK namelist (not default value in ICON)
 vmr_cfc11                    = 240.e-12    ! CK namelist (not default value in ICON)
 vmr_cfc12                    = 532.e-12    ! CK namelist (not default value in ICON)
 ecrad_data_path              = "./ecrad_data"  ! ECRad data from externals of this source code.
/

&nonhydrostatic_nml
 iadv_rhotheta                = 2            ! Advection method for density and potential density (Default)
 ivctype                      = 2            ! Sleeve vertical coordinate, default
 itime_scheme                 = 4            ! default Contravariant vertical velocityin predictor step, velocty tendencis in corrector step
 exner_expol                  = 0.333        ! Temporal extrapolation (default = 1/3) (For R2B5 or Coarser use 1/2 and 2/3 recomendation)
 vwind_offctr                 = 0.2           ! Off-centering vertical wind solver
 damp_height                  = 40000.        ! AD recomendation (rayeigh damping starts at this lelev in meters)
 rayleigh_coeff               = 0.2           ! AD recomendation based on APE testing wiht Praveen-
 divdamp_order                = 24            ! Default value (Combined second and fourth order divergence damping
 divdamp_type                 = 32            ! Defaul value (3D divergence)
 divdamp_fac                  = 0.004         ! Default value (scaling factor for divergence damping)
 divdamp_trans_start          = 12500.0       ! Lower bound of transition zone between 2D and 3D divergence damoping)
 divdamp_trans_end            = 17500.0       ! Upper bound
 igradp_method                = 3             ! Default (Discritization of horizontal pressure gradient (tyloer expansion))
 l_zdiffu_t                   = .true.       ! Smagorinsky temperature diffuciton truly horizontally over steep slopes
 thslp_zdiffu                 = 0.02         ! Slope thershold for activation of temperature difusion
 thhgtd_zdiffu                = 125.         ! Height difference between two neighbouring points ! CLM value
 htop_moist_proc              = 22500.       ! Height above whihc ophysical processes are turned off
 hbot_qvsubstep               = 16000.       ! Height above which Qv i s advected wih substepping
 ndyn_substeps                 = 5           ! Default value for dynamical sub-stepping
/

&sleve_nml
  min_lay_thckn   = 20.         ! Layer thickness of lowermost layer (CLM recommendation)
  max_lay_thckn   = 400.        ! May layer thickness below th height given by htop_thcknlimit (CLM & NWP recomendation 400)
  htop_thcknlimit = 15000.     ! Height below which the layer thickness does not exceed max_lay_thckn (CLM recomendation)
  top_height      = 85000.     ! Height of the model top (AD recomendation)
  stretch_fac     = 0.9        ! Stretching factor to vary distribution of model levels (<1 increase layer thicknedd near model top)
 decay_scale_1    = 4000.  ! Decay scale of large-scale topography  (Default Value)
 decay_scale_2    = 2500.  ! Decay scale of small-scale topography  (Default Value)
 decay_exp        = 1.2    ! Exponent of decay function (Default value in meters)
 flat_height      = 16000. ! Height above whihc coordinatre surfaces are flat  (default value)
/

&dynamics_nml
 iequations                   = 3      ! Non-hydrostatic atmsophere
 divavg_cntrwgt               = 0.50    ! Weight of central cell for divergence averaging
 lcoriolis                    = .true. ! Coriolis force ofcourse true for real cases
/

&transport_nml
 ihadv_tracer                =               2,2,2,2,2,2         ! (AD recomendaiton)gdm: 52 combination of hybrid FFSL/Miura3 with subcycling
 itype_hlimit                =               4,4,4,4,4,4         ! (AD recomendaiton) type of limiter for horizontal transport
 ivadv_tracer                =               3,3,3,3,3,3         ! (AD recomendaiton) tracer specific method to compute vertical advection
 itype_vlimit                =               1,1,1,1,1,1         ! (AD recomendaiton) Type of limiter for vertical transport
 ivlimit_selective           =               1,1,1,1,1,1
 llsq_svd                    =                     .true.        ! (AD recomendaiton)use SV decomposition for least squares design matrix
/

&diffusion_nml
 hdiff_order                  = 5      ! Smagorinsky diffusiton combined with 4rth order background diffusion
 itype_vn_diffu               = 1      ! (u,v reconstruction atvertices only)  Default of CLM
 itype_t_diffu                = 2      ! (Discritization of temp diffusion, default value of CLM)
 hdiff_efdt_ratio             = 32.0       ! Ratio iof e-forlding time to time step, recomemded values above 30 (CLM value)
 hdiff_smag_fac               = 0.025      ! Scaling factor for Smagorninsky diffusion (CLM value)
 lhdiff_vn                    = .true.     ! Diffusion of horizontal winds
 lhdiff_temp                  = .true.     ! Diffusion of temperature field
/

&gridref_nml
 grf_intmethod_ct             = 2  ! interpolation method for grid refinment (gradient based interpolation, default value)
 grf_intmethod_e              = 6   ! default 6 Interpolation ,method for edge based bariables
 grf_tracfbk                  = 2   ! Bilinear interpolation
 denom_diffu_v                = 150.  ! Deniminator for lateral boundary diffusion of temperature
/



&extpar_nml
 extpar_filename              = "${extpar_file}"
 itopo                        = 1    ! Topography read from file
 n_iter_smooth_topo             = 1  ! iterations of topography smoother
 heightdiff_threshold           = 3000. ! height difference between neighboring grid points above which additional local nabla2 diffusion is applied
 hgtdiff_max_smooth_topo        = 750.  ! RMS height difference to neighbor grid points at which the smoothing pre-factor fac_smooth_topo reaches its maximum value (CLM value)
 itype_vegetation_cycle         = 3    !NEW  (CLM value , but not defined. Annual cycle of Leaf Area Index, use T2M to get realistic values)
 itype_lwemiss                  = 2    !NEW  Type of data for Long wave surfae emissitvity (Read from monthly climatologoies from expar file)
/



! This are NWP tuning recomendation from CLM community

&nwp_tuning_nml
  itune_albedo = 0
  tune_gkwake   = 1.5
  tune_gfrcrit  = 0.425
  tune_gkdrag   = 0.075
  tune_dust_abs = 1.
  tune_zvz0i    = 0.85
  tune_box_liq_asy = 3.25
  tune_minsnowfrac = 0.2
  tune_gfluxlaun  = 3.75e-3
  tune_rcucov = 0.075
  tune_rhebc_land = 0.825
  tune_gust_factor=7.0
/

!Turbulance diffusion tuining based on the CLM community recomendation (This needs to be checked for Silje & Pothapakula Namelist)

&turbdiff_nml
  tkhmin  = 0.6
  tkhmin_strat = 1.0
  tkmmin        = 0.75
  pat_len       = 750.
  c_diff  =  0.2
  rlam_heat = 10.0
  rat_sea =  0.8
  ltkesso = .true.
  frcsmot       = 0.2
  imode_frcsmot = 2
  alpha1  = 0.125
  icldm_turb = 1
  itype_sher = 1
  ltkeshs       = .true.
  a_hshr        = 2.0
/


! This corresponds to the TERRA namelist based on the CLM community recomendation

&lnd_nml
  sstice_mode    = 4  ! 4: SST and sea ice fraction are updated daily,
                       !    based on actual monthly means
!  ci_td_filename = '${sst_file}/SIC_SeaIce_CMIP_CI_PCMDI-AMIP-1-1-7_197801-202012_daily_0013_R02B04_G.nc'
!  sst_td_filename= '${sic_file}/SST_CMIP_PCMDI-AMIP-1-1-7_197801-202012_daily_0013_R02B04_G.nc'
  ntiles         = 3
  nlev_snow      = 1
  zml_soil       = ${ZML_SOIL}
  lmulti_snow    = .false.
  itype_heatcond = 3
  idiag_snowfrac = 20
  itype_snowevap = 3
  lsnowtile      = .true.
  lseaice        = .true.
  llake          = .true.
  itype_lndtbl   = 4
  itype_evsl     = 4
  itype_trvg     = 3
  itype_root     = 2
  itype_canopy   = 2
  cwimax_ml      = 5.e-4
  c_soil         = 1.25
  c_soil_urb     = 0.5
  lprog_albsi    = .true.
/
EOF

# -------------------------------------
# Consistent with PyICON tools. 
# -------------------------------------

if [[ "$output_atm_mon" == "yes" ]]; then
  cat >> ${atmo_namelist} << EOF
&output_nml
 output_filename  = "${EXPNAME}_atm_mon"
 filename_format  = "<output_filename>_<datetime2>"
 filetype         = 5                                ! output format: 2=GRIB2, 4=NETCDFv2, 5=NETCDFv4
 remap            = 0
 mode             = 1                                ! 1: forecast mode (relative t-axis), 2: climate mode (absolute t-axis)
 operation        = 'mean'                           ! mean over output interval
 output_grid      = .FALSE.
 output_start     = "${start_date}"
 output_end       = "${end_date}"
 output_interval  = "${atm_output_interval}"
 steps_per_file   = 1
! file_interval    = "${atm_file_interval}"
 include_last     = .FALSE.
 ml_varlist       = 'tas_gmean','rsdt_gmean','rsut_gmean','rlut_gmean','radtop_gmean',
                    'prec_gmean','evap_gmean','pme_gmean'
/
EOF
fi


if [[ "$output_atm_3d" == "yes" ]]; then
  cat >> ${atmo_namelist} << EOF
&output_nml
 output_filename  = "${EXPNAME}_atm_3d_ml"
 filename_format  = "<output_filename>_<datetime2>"
 filetype         = 5
 remap            = 0
 mode             = 1
 operation        = 'mean'
 output_grid      = .FALSE.
 output_start     = "${start_date}"
 output_end       = "${end_date}"
 output_interval  = "${atm_output_interval}"
 steps_per_file   = 1 
! file_interval    = "${atm_file_interval}"
 include_last     = .FALSE.
 ml_varlist       = 'pres', 'geopot', 'temp', 'u', 'v', 'qv', 'rh', 'clc', 'tot_qc_dia','tot_qi_dia'

/
EOF
fi


if [[ "$output_atm_2d" == "yes" ]]; then
  #
  cat >> ${atmo_namelist} << EOF
&output_nml
 output_filename  = "${EXPNAME}_atm_2d_ml"
 filename_format  = "<output_filename>_<datetime2>"
 filetype         = 5
 remap            = 0
 mode             = 1
 operation        = 'mean'
 output_grid      = .FALSE.
 output_start     = "${start_date}"
 output_end       = "${end_date}"
 output_interval  = "${atm_output_interval}"
 steps_per_file   = 1
! file_interval    = "${atm_file_interval}"
 include_last     = .FALSE.
 ml_varlist       = 'pres_msl', 'umfl_s', 'vmfl_s', 'sp_10m', 't_2m', 't_s', 't_seasfc', 'tot_prec_rate', 'clct', 'tqv_dia', 'tqc_dia', 'tqi_dia', 'sou_t', 'sob_t', 'thb_t', 'sob_s', 'thb_s', 'shfl_s', 'lhfl_s', 'qhfl_s','fr_land', 'fr_seaice' 
/
EOF
fi

if [[ "$output_atm_2d_CLM" == "yes" ]]; then
  #
  cat >> ${atmo_namelist} << EOF

&output_nml
 output_filename  = "${EXPNAME}_atm_2d_out3"          ! file name base
 filename_format  = "${EXPNAME}_out3_<datetime2>"     ! Output file format
 filetype         = 5 ! NetCDF4
 output_start     = "${start_date}"
 output_end       = "${end_date}"
 output_interval  = "${atm_output_interval_2d}"
 file_interval    = "${atm_file_interval}"
 ml_varlist       = 'clct','clct_mod','pres_msl','pres_sfc','qv_2m','rh_2m','runoff_g','runoff_s','rain_con','snow_con','rain_gsp','snow_gsp','tot_prec','t_2m','td_2m','u_10m','v_10m','gust10','sp_10m','snow_melt'
include_last     = .true.
output_grid      =  .true.
mode             = 1
operation        = 'mean'
/
EOF
fi


if [[ "$output_atm_3d_CLM" == "yes" ]]; then
  #
  cat >> ${atmo_namelist} << EOF

&output_nml
 output_filename  = "${EXPNAME}_atm_2d_out8"          ! file name base
 filename_format  = "${EXPNAME}_out8_<datetime2>"     ! Output file format
 filetype         = 5 ! NetCDF4
 output_start     = "${start_date}"
 output_end       = "${end_date}"
 output_interval  = "${atm_output_interval_2d}"
 file_interval    = "${atm_file_interval}"
 include_last     = .true.
 ml_varlist       = 'pres','qv','rh','temp','u','v',
 output_grid      =  .true.
 mode             = 1
 operation        = 'mean'
/

EOF
fi


#_____________________________________________________________________________
# Define the input

# namelist files
add_required_file ${workdir}/${atmo_namelist}      ./
add_required_file ${atmo_namelist}      ./
cp ${atmo_namelist} ${outputdir}

# experiment directory, with plenty of space, create if new

EXPDIR=${outputdir}
if [ ! -d ${EXPDIR} ] ;  then
  mkdir -p ${EXPDIR}
fi
#
ls -ld ${EXPDIR}
check_error $? "${EXPDIR} does not exist?"

cd ${EXPDIR}

#-----------------------------------------------------------------------------

run_atmo=${run_atmo="false"}
if [ x$atmo_namelist != x ]; then
  run_atmo="true"
fi

#-----------------------------------------------------------------------------
# sstice global runmean file

ln -sf ${analysis_file}              ./ifs2icon_1979010100_${gridID}_${RES}_G.nc
ln -sf ${extpar_file}                  ./external_parameter_icon_${gridID}_${RES}_G_tiles_ppk.nc
ln -sf ${atmo_dyn_grid_dir}/icon_grid_0013_R02B04_G.nc   ./icon_grid_${gridID}_${RES}_G.nc
ln -sf ${ecrad_file}             ./ecrad_data
ln -sf /scratch/snx3000/ckroll/pac3ts/common/clean_build_release2/icon-dsl_v0.2.0/externals/jsbach/data/lctlib_nlct21.def ./lctlib_nlct21.def

# link SST & sea-ice

#ln -sf ${sst_file}/SST_${YYYY}_${MM}_icon_grid_0013_R02B04_G.nc SST_${YYYY}_${MM}_icon_grid_0013_R02B04_G.nc
#ln -sf ${sst_file}/SST_${NEXT_YYYY}_${NEXT_MM}_icon_grid_0013_R02B04_G.nc SST_${NEXT_YYYY}_${NEXT_MM}_icon_grid_0013_R02B04_G.nc
#ln -sf ${ice_file}/CI_${YYYY}_${MM}_icon_grid_0013_R02B04_G.nc CI_${YYYY}_${MM}_icon_grid_0013_R02B04_G.nc
#ln -sf ${ice_file}/CI_${NEXT_YYYY}_${NEXT_MM}_icon_grid_0013_R02B04_G.nc CI_${NEXT_YYYY}_${NEXT_MM}_icon_grid_0013_R02B04_G.nc

ln -sf ${sst_file_dir}/SST_*_*_icon_grid_0013_R02B04_G.nc .
ln -sf ${ice_file_dir}/CI_*_*_icon_grid_0013_R02B04_G.nc .



#-----------------------------------------------------------------------------
#
# create ICON master namelist
# ------------------------
# For a complete list see Namelist_overview and Namelist_overview.pdf

#-----------------------------------------------------------------------------
# create master_namelist
# CK extended master_namelist creation to allow for restart
master_namelist=icon_master.namelist
restart=.false.
file_path="${basedir}/experiments/${EXPNAME}/finish.status"
if [ -e "$file_path" ]; then
    echo "The file $file_path exists."
file_content=$(cat "$file_path")
echo "File content of is finish.status"
echo "${file_content}"
if [  ${file_content} == "RESTART" ]; then
  restart=.true.
  touch "${outputdir}/isRestartRun.sem"
  echo "start from restart was initiated due to finish.status, adapting master_nml"
fi
fi
echo "after restart check"
echo "$restart"


cat > $master_namelist << EOF
&master_nml
 lrestart             = $restart
/
&master_time_control_nml
 calendar             = 'proleptic gregorian'
 checkpointTimeIntval = "$checkpoint_interval"
 restartTimeIntval    = "$restart_interval"
 experimentStartDate  = "$start_date"
 experimentStopDate   = "$end_date"
/
&time_nml
 is_relative_time = .false.
/
&master_model_nml
  model_type=1
  model_name="atmo"
  model_namelist_filename="${atmo_namelist}"
  model_min_rank=1
  model_max_rank=65536
  model_inc_rank=1
/
&jsb_control_nml
 is_standalone      = .false.
 restart_jsbach     = ${lrestart}
 debug_level        = 0
 timer_level        = 0
/
&jsb_model_nml
 model_id = 1
 model_name = 'JSBACH'
 model_shortname = 'jsb'
 model_description = 'JSBACH'
 model_namelist_filename = "${jsbach_namelist}"
/
EOF

#-----------------------------------------------------------------------------

cat > map_file.analysis << EOF
# internal name     GRIB2 shortName
theta_v             THETA_V
rho                 DEN
vn                  VN
u                   U
v                   V
w                   W
tke                 TKE
temp                T
pres                P
qv                  QV
qc                  QC
qi                  QI
qr                  QR
qs                  QS
t_g                 T_G
qv_s                QV_S
fr_seaice           FR_ICE
alb_si              ALB_SEAICE
t_ice               T_ICE
h_ice               H_ICE
t_snow              T_SNOW
freshsnow           FRESHSNW
snowfrac_lc         SNOWC
w_snow              W_SNOW
rho_snow            RHO_SNOW
h_snow              H_SNOW
w_i                 W_I
w_so                W_SO
w_so_ice            W_SO_ICE
t_so                T_SO
smi                 SMI
gz0                 Z0
pres_sfc            PS
z_ifc               HHL
t_mnw_lk            T_MNW_LK
t_wml_lk            T_WML_LK
h_ml_lk             H_ML_LK
t_bot_lk            T_BOT_LK
c_t_lk              C_T_LK
t_b1_lk             T_B1_LK
h_b1_lk             H_B1_LK
EOF

cat > map_file.forecast << EOF
# GRIB2 shortName   internal name
  alb_rad           ALBDIF
  alb_seaice        ALB_SI
  apab_s            ASWFLX_PAR_SFC
  aswdifd_s         ASODIFD_S
  aswdifu_s         ASODIFU_S
  aswdir_s          ASODIRD_S
  cape_con          CAPE
  den               RHO
  dtke_con          DDT_TKE_PCONV
  dtke_hsh          DDT_TKE_HSH
  fi                GEOPOT
  fr_ice            FR_SEAICE
  freshsnw          FRESHSNOW
  hhl               Z_IFC
  hsurf             TOPOGRAPHY_C
  p                 PRES
  pmsl              PRES_MSL
  ps                PRES_SFC
  relhum            RH
  relhum_2m         RH_2M
  snowc             SNOWFRAC_LC
  sobs_rad          SOB_S
  t                 TEMP
  t_sea             T_SEASFC
  thbs_rad          THB_S
  vmax_10m          GUST10
  z0                GZ0 
EOF
#-----------------------------------------------------------------------------
#
#  check, if input data are available
#
echo -n "Check for initial data ... "
if [[ -r "$analysis_file" ]]
then
    echo "$analysis_file AVAILABLE"
else
    echo "$analysis_file MISSING"
    exit 1
fi
#
echo -n "Check for grid file ... "
if [[ -r "$atmo_dyn_grid" ]]
then
    echo "$atmo_dyn_grid AVAILABLE"
else
    echo "$atmo_dyn_grid MISSING"
    exit 1
fi
#
echo -n "Check for extpar data ... "
if [[ -r "$extpar_file" ]]
then
    echo "$extpar_file AVAILABLE"
else
    echo "$extpar_file MISSING"
    exit 1
fi
#
##  This is commented by PPK, as this is not required for a check"
#echo -n "Check for time varying SST/sea ice data ... "
#if [[ -r "$sst_file" ]]
#then
#    echo "$sst_file AVAILABLE"
#else
#    echo "$sst_file MISSING"
#    exit 1
#fi
#
#echo -n "Check for time varying sea ice data ... "
#if [[ -r "$ice_file" ]]
#then
#    echo "$ice_file AVAILABLE"
#else
#    echo "$ice_file MISSING"
#    exit 1
#fi
#  get model
#
export MODEL=${bindir}/icon
#export MODEL="/scratch/snx3000/ppothapa/dsl_bug_fix/icon-exclaim/bin/icon"
#
ls -l ${MODEL}
check_error $? "${MODEL} does not exist?"
#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
#
# start experiment
# for safety reasons one needs to delete broken output files of a, perhaps, previous run
#nextdate=$(ls -l multifile_restart_atm.mfr | awk -F"[a-zA-Z_=&\"]*" '{print $8}')
#rm -f ${EXPNAME}_*_${nextdate}T*Z.grb
#
rm -f finish.status
date
${START} ${MODEL}
date
#
if [ -r finish.status ] ; then
  check_error 0 "${START} ${MODEL}"
else
  check_error -1 "${START} ${MODEL}"
fi
#
#-----------------------------------------------------------------------------
#
finish_status=$(cat finish.status)
echo $finish_status
echo "============================"
echo "Script run successfully: $finish_status"
echo "============================"

#-----------------------------------------------------------------------------
#!/bin/ksh
#=============================================================================
#
# This section of the run script prepares and starts the model integration. 
#
# MODEL and START must be defined as environment variables or
# they must be substituted with appropriate values.
#
# Marco Giorgetta, MPI-M, 2010-04-21
#
#-----------------------------------------------------------------------------
final_status_file=${basedir}/run/${job_name}.final_status
rm -f ${final_status_file}
#-----------------------------------------------------------------------------
#
# directories definition
#
RUNSCRIPTDIR=${basedir}/run
if [ x$grids_folder = x ] ; then
   HGRIDDIR=${basedir}/grids
else
   HGRIDDIR=$grids_folder
fi

make_and_change_to_experiment_dir

#-----------------------------------------------------------------------------
final_status_file=${RUNSCRIPTDIR}/${job_name}.final_status
rm -f ${final_status_file}

#-----------------------------------------------------------------------------
# set up the model lists if they do not exist
# this works for single model runs
# for coupled runs the lists should be declared explicilty
if [ x$namelist_list = x ]; then
  minrank_list[0]=0
  maxrank_list[0]=65535
  incrank_list[0]=1
  if [ x$atmo_namelist != x ]; then
    # this is the atmo model
    namelist_list[0]="$atmo_namelist"
    modelname_list[0]="atmo"
    modeltype_list[0]=1
    run_atmo="true"
  elif [ x$ocean_namelist != x ]; then
    # this is the ocean model
    namelist_list[0]="$ocean_namelist"
    modelname_list[0]="oce"
    modeltype_list[0]=2
  elif [ x$psrad_namelist != x ]; then
    # this is the psrad model
    namelist_list[0]="$psrad_namelist"
    modelname_list[0]="psrad"
    modeltype_list[0]=3
  elif [ x$hamocc_namelist != x ]; then
    # this is the hamocc model
    namelist_list[0]="$hamocc_namelist"
    modelname_list[0]="hamocc"
    modeltype_list[0]=4
  elif [ x$jsbach_namelist != x ]; then
    # this is the jsbach standalone model
    namelist_list[0]="$jsbach_namelist"
    modelname_list[0]="jsbach"
    modeltype_list[0]=5
    run_jsbach_standalone="true"
  elif [ x$testbed_namelist != x ]; then
    # this is the testbed model
    namelist_list[0]="$testbed_namelist"
    modelname_list[0]="testbed"
    modeltype_list[0]=99
  else
    check_error 1 "No namelist is defined"
  fi 
fi

#-----------------------------------------------------------------------------


#-----------------------------------------------------------------------------
#Corrected RESTART CK
file_path="${basedir}/experiments/${EXPNAME}/finish.status"
echo "${ouputdir}/finish.status"
file_content=$(cat "$file_path")
# Display the content
echo "File content: of is finish.status"
echo "${file_content}"
if [  ${file_content} == "RESTART" ]; then
  restart=.true.
  touch "${outputdir}/isRestartRun.sem"
  echo "restart was initiated due to finish.status"
  #  do not delete switch-file, to enable restart after unintended abort
  #[[ -f ${restartSemaphoreFilename} ]] && rm ${restartSemaphoreFilename}
fi
echo "after restart setting"
echo "$restart"

#END AUTOMATIC_RESTART_SETUP
#
# wait 5min to let GPFS finish the write operations
if [ "x$restart" != 'x.false.' -a "x$submit" != 'x' ]; then
  if [ x$(df -T ${EXPDIR} | cut -d ' ' -f 2) = gpfs ]; then
    sleep 10;
  fi
fi
# fill some checks

run_atmo=${run_atmo="false"}
if [ x$atmo_namelist != x ]; then
  run_atmo="true"
  run_jsbach_standalone="false"
fi
run_jsbach=${run_jsbach="false"}
if [ x$jsbach_namelist != x ]; then
  run_jsbach="true"
fi
run_ocean=${run_ocean="false"}
if [ x$ocean_namelist != x ]; then
  run_ocean="true"
fi
run_psrad=${run_psrad="false"}
if [ x$psrad_namelist != x ]; then
  run_psrad="true"
fi
run_hamocc=${run_hamocc="false"}
if [ x$hamocc_namelist != x ]; then
  run_hamocc="true"
fi

#-----------------------------------------------------------------------------
# add grids to required files
all_grids="${atmo_dyn_grids} ${atmo_rad_grids} ${ocean_grids}"
for gridfile in ${all_grids}; do
  #
  gridfile=${gridfile//\'/} # strip all ' in case ' is used to delimit the grid names
  gridfile=${gridfile//\"/} # strip all " in case " is used to delimit the grid names
  gridfile=${gridfile//\,/} # strip all , in case , is used to separate the grid names
  #
  grfinfofile=${gridfile%.nc}-grfinfo.nc
  #
  ls -l ${HGRIDDIR}/$gridfile
  check_error $? "${HGRIDDIR}/$gridfile does not exist."
  add_link_file ${HGRIDDIR}/${gridfile} ./
  if [ -f ${HGRIDDIR}/${grfinfofile} ]; then    
    add_link_file ${HGRIDDIR}/${grfinfofile} ./
  fi
done
#-----------------------------------------------------------------------------
# print_required_files
copy_required_files
link_required_files

read_restart_namelists=${read_restart_namelists:=".false."}

#-----------------------------------------------------------------------------
#
# create ICON master namelist
# ------------------------
# For a complete list see Namelist_overview and Namelist_overview.pdf

#-----------------------------------------------------------------------------
# create master_namelist
if [ -z "$dont_create_icon_master_namelist" ]; then
  master_namelist=icon_master.namelist

  calendar=${calendar:="proleptic gregorian"}
  calendar_type=${calendar_type:=1}
  {
    echo "&master_nml"
    echo " lrestart               =  $restart"
    echo " read_restart_namelists =  $read_restart_namelists"
    echo "/"

    if [ -z "$nsteps" ]; then
      echo "&master_time_control_nml"
      echo " calendar             = '$calendar'"
      echo " experimentStartDate  = '$start_date'"
      echo " restartTimeIntval    = '$restart_interval'"
      echo " checkpointTimeIntval = '$checkpoint_interval'"
      if [ -n "$end_date" ]; then
        echo " experimentStopDate = '$end_date'"
      fi
      echo "/"

      echo "&time_nml"
      echo " is_relative_time     = .false."
      echo "/"

    else # $nsteps is set -> use time_nml:ini_datetime_string
      echo "&time_nml"
      echo " calendar             =  $calendar_type"
      echo " ini_datetime_string  = '$start_date'"
      echo " dt_restart           =  $dt_restart"
      echo "/"
    fi
  } > $master_namelist

fi
#-----------------------------------------------------------------------------

echo "masternamelist should be created here $(pwd)"
#-----------------------------------------------------------------------------
# add model component to master_namelist
add_component_to_master_namelist()
{
  model_namelist_filename=$1
  if [ x${dont_create_icon_master_namelist+set} != xset ]; then
    model_name=$2
    model_type=$3
    model_min_rank=$4
    model_max_rank=$5
    model_inc_rank=$6
    model_rank_group_size=$7
    cat >> $master_namelist << EOF
&master_model_nml
  model_name="$model_name"
  model_namelist_filename="$model_namelist_filename"
  model_type=$model_type
  model_min_rank=$model_min_rank
  model_max_rank=$model_max_rank
  model_inc_rank=$model_inc_rank
  model_rank_group_size=$model_rank_group_size
/
EOF
  fi

  #-----------
  #get namelist
  #atmo_namelist=${outputdir}/NAMELIST_${EXPNAME} CK HAD TO ADAPT THIS PART FOR RESTART CORRECTION
  #echo ${outputdir}/NAMELIST_${EXPNAME}
  #echo ${EXPDIR}/$atmo_namelist
  #if [ -f ${EXPDIR}/NAMELIST_${EXPNAME} ] ; then
    #mv -f ${EXPDIR}/NAMELIST_${EXPNAME} ${EXPDIR}
    #check_error $? "mv -f ${EXPDIR}/NAMELIST_${EXPNAME} ${EXPDIR}"
  #else
    #check_error 1 "${EXPDIR}/NAMELIST_${EXPNAME} does not exist"
  #fi 
}
#-----------------------------------------------------------------------------

echo "Current working directory: $(pwd) before had to add this line "
 

#had to add this line
no_of_models=${#namelist_list[*]}
echo "no_of_models=$no_of_models"

rank_group_size=1
j=0
while [ $j -lt ${no_of_models} ]
do
  add_component_to_master_namelist "${namelist_list[$j]}" "${modelname_list[$j]}" ${modeltype_list[$j]} ${minrank_list[$j]} ${maxrank_list[$j]} ${incrank_list[$j]} ${rank_group_size}
  j=`expr ${j} + 1`
done

echo "Current working directory: $(pwd) before cp master"
cp icon_master.namelist ${outputdir}     
#-----------------------------------------------------------------------------
# Add JSBACH part to master_namelist
# For several domains, $jsbach_namelist is only the basename for each domain's jsbach namelist;
#   the actual namelist files are appended by suffixes '_d1', '_d2', etc.

if [[ $run_jsbach == @(yes|true) ]]; then
  cat >> $master_namelist << EOF
&jsb_control_nml
 is_standalone      = .${run_jsbach_standalone:=false}.
 restart_jsbach     = ${restart}
 debug_level        = 0
 timer_level        = 0
EOF
if [[ ${run_jsbach_standalone} == true ]]; then
  cat >> $master_namelist << EOF
 l_force_from_obs   = .${l_force_from_obs:-false}.
EOF
fi
  cat >> $master_namelist << EOF
/
EOF
#
if [[ -n ${atmo_dyn_grids} ]]; then
  no_of_domains=${#atmo_dyn_grids[@]}
else
  no_of_domains=1
fi
echo "no_of_domains=$no_of_domains"
domain=""
domain_suffix=""
j=1
while [ $j -le ${no_of_domains} ]
do
  if [[ $no_of_domains -gt 1 ]]; then
    # no_of_domains < 10 !
    domain=" DOM0${j}"
    domain_suffix="_d${j}"
  fi
  cat >> $master_namelist << EOF
&jsb_model_nml
 model_id = $j
 model_name = "JSBACH${domain}"
 model_shortname = "jsb${domain_suffix}"
 model_description = 'JSBACH land surface model'
 model_namelist_filename = "${jsbach_namelist}${domain_suffix}"
/
EOF
#  if [[ ${run_jsbach_standalone} != true ]]; then
#   if [[ -f ${jsbach_namelist}${domain_suffix} ]] ; then
#     mv ${jsbach_namelist}${domain_suffix} ${RUNSCRIPTDIR}
#      check_error $? "mv ${jsbach_namelist}${domain_suffix}"
#    else
#      check_error 1 "${jsbach_namelist}${domain_suffix} does not exist"
#	 check_error 1 "${jsbach_namelist}${domain_suffix} does not exist"
#   fi
#  fi
  j=`expr ${j} + 1`
done
fi
#
#  get model
#
echo "Current working directory: $(pwd) before get model"
ls -l ${MODEL}
check_error $? "${MODEL} does not exist?"
#
ldd ${MODEL}
#
#-----------------------------------------------------------------------------
#
# start experiment
#
echo "Current working directory: $(pwd) starting exp"
#
date
set -x
${START} ${MODEL} # > out.txt 2>&1
set +x
date
#
if [ -r finish.status ] ; then
  check_final_status 0 "${START} ${MODEL}"
else
  check_final_status -1 "${START} ${MODEL}"
fi
#
#-----------------------------------------------------------------------------
#
finish_status=`cat finish.status`
echo $finish_status
echo "============================"
echo "Script run successfully: $finish_status"
echo "============================"

#-----------------------------------------------------------------------------
# rm output_schedule_steps*
#-----------------------------------------------------------------------------
if [[ "x$use_hamocc" = "xyes" ]]; then
# store HAMOCC log file
strg="$(ls -rt ${EXPNAME}_hamocc_EU*.nc* | tail -1 )"
prefx="${EXPNAME}_hamocc_EU_tendencies"
foo=${strg##${prefx}}
foo=${foo%%.*}
bgcout_file="bgcout_${foo}"
mv bgcout $bgcout_file
fi
#-----------------------------------------------------------------------------
namelist_list=""
#-----------------------------------------------------------------------------
# check if we have to restart, ie resubmit
#   Note: this is a different mechanism from checking the restart
if [ $finish_status = "RESTART" ] ; then
  echo "restart next experiment..."
  this_script="${RUNSCRIPTDIR}/${job_name}"
  echo 'this_script: ' "$this_script"
  touch ${restartSemaphoreFilename}
  cd ${RUNSCRIPTDIR}
  ${submit} $this_script
else
  [[ -f ${restartSemaphoreFilename} ]] && rm ${restartSemaphoreFilename}
fi

#-----------------------------------------------------------------------------
# automatic call/submission of post processing if available
if [ "x${autoPostProcessing}" = "xtrue" ]; then
  # check if there is a postprocessing is available
  cd ${RUNSCRIPTDIR}
  targetPostProcessingScript="./post.${EXPNAME}.run"
  [[ -x $targetPostProcessingScript ]] && ${submit} ${targetPostProcessingScript}
  cd -
fi

#-----------------------------------------------------------------------------

cd $RUNSCRIPTDIR

#-----------------------------------------------------------------------------

	
# exit 0
#
# vim:ft=sh

